{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-config üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º –ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\" üá∫üá∏ To Citizens of Russia We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" This package is considered feature-complete, and is now in security-only maintenance mode, following a decision by the Technical Steering Committee . If you have a security issue, please follow our security reporting guidelines . If you wish to take on the role of maintainer, please nominate yourself laminas-config is designed to simplify access to configuration data within applications. It provides a nested object property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of media supporting hierarchical data storage. File issues at https://github.com/laminas/laminas-config/issues Documentation is at https://docs.laminas.dev/laminas-config/","title":"Home"},{"location":"#laminas-config","text":"","title":"laminas-config"},{"location":"#_1","text":"–ú—ã, —É—á–∞—Å—Ç–Ω–∏–∫–∏ Laminas, —Ä–æ–¥–∏–ª–∏—Å—å –∏ –∂–∏–≤–µ–º –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö. –£ –º–Ω–æ–≥–∏—Ö –∏–∑ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –∏ –∫–æ–ª–ª–µ–≥–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –≤ –£–∫—Ä–∞–∏–Ω–µ. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å —Ä–æ–¥–∏–ª–∏—Å—å –≤ –†–æ—Å—Å–∏–∏. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ –Ω–∞—Å –∂–∏–≤—É—Ç –≤ –†–æ—Å—Å–∏–∏. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±–∞–±—É—à–∫–∏ –∏ –¥–µ–¥—É—à–∫–∏ —Å—Ä–∞–∂–∞–ª–∏—Å—å —Å —Ñ–∞—à–∏—Å—Ç–∞–º–∏ –≤–æ –í—Ç–æ—Ä–æ–π –º–∏—Ä–æ–≤–æ–π –≤–æ–π–Ω–µ. –ó–¥–µ—Å—å –Ω–∏–∫—Ç–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ñ–∞—à–∏–∑–º. –£ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∞—Å –µ—Å—Ç—å —É–∫—Ä–∞–∏–Ω—Å–∫–∞—è —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏—Ü–∞, –∫–æ—Ç–æ—Ä–∞—è —Å–ø–∞—Å–ª–∞—Å—å –∏–∑ –¥–æ–º–∞ –≤–º–µ—Å—Ç–µ —Å —Å—ã–Ω–æ–º. –ü–æ–µ–∑–¥ –∑–∞–¥–µ—Ä–∂–∞–ª—Å—è –∏–∑-–∑–∞ –±–æ–º–±–µ–∂–∫–∏ –Ω–∞ –¥–æ—Ä–æ–≥–µ –≤–ø–µ—Ä–µ–¥–∏. –£ –Ω–∞—Å –µ—Å—Ç—å –¥—Ä—É–∑—å—è, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä—è—á—É—Ç—Å—è –≤ –±–æ–º–±–æ—É–±–µ–∂–∏—â–∞—Ö. –ú—ã —Å —Ç—Ä–µ–≤–æ–≥–æ–π –∂–¥–µ–º –≤–µ—Å—Ç–æ—á–∫–∏ –æ—Ç –Ω–∏—Ö –ø–æ—Å–ª–µ –≤–æ–∑–¥—É—à–Ω—ã—Ö –Ω–∞–ª–µ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å–ø–æ—Ä—è–¥–æ—á–Ω–æ –Ω–∞–Ω–æ—Å—è—Ç —É–¥–∞—Ä—ã –∏ –ø–æ–ø–∞–¥–∞—é—Ç –ø–æ –±–æ–ª—å–Ω–∏—Ü–∞–º, —à–∫–æ–ª–∞–º, –¥–µ—Ç—Å–∫–∏–º —Å–∞–¥–∞–º –∏ –¥–æ–º–∞–º. –ú—ã –Ω–µ –±–µ—Ä–µ–º —ç—Ç–æ –∏–∑ –∫–∞–∫–∏—Ö-–ª–∏–±–æ –°–ú–ò. –ú—ã –Ω–∞–±–ª—é–¥–∞–µ–º —ç—Ç–æ –Ω–∞–ø—Ä—è–º—É—é. –í—ã –¥–æ–≤–µ—Ä—è–µ—Ç–µ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, —á—Ç–æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–∞—à–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∏ –º—ã –ø—Ä–æ—Å–∏–º –≤–∞—Å –¥–æ–≤–µ—Ä–∏—Ç—å—Å—è –Ω–∞–º –≤–Ω–æ–≤—å. –ú—ã –Ω—É–∂–¥–∞–µ–º—Å—è –≤ –ø–æ–º–æ—â–∏. –í—ã—Ö–æ–¥–∏—Ç–µ –∏ –ø—Ä–æ—Ç–µ—Å—Ç—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤ —ç—Ç–æ–π –±–µ—Å–ø–æ–ª–µ–∑–Ω–æ–π –≤–æ–π–Ω—ã. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∫—Ä–æ–≤–æ–ø—Ä–æ–ª–∏—Ç–∏–µ. –°–∫–∞–∂–∏—Ç–µ \"–ù–µ—Ç –≤–æ–π–Ω–µ!\"","title":"üá∑üá∫ –†—É—Å—Å–∫–∏–º –≥—Ä–∞–∂–¥–∞–Ω–∞–º"},{"location":"#to-citizens-of-russia","text":"We at Laminas come from all over the world. Many of us have friends, family and colleagues in both Russia and Ukraine. Some of us were born in Russia. Some of us currently live in Russia. Some have grandparents who fought Nazis in World War II. Nobody here supports fascism. One team member has a Ukrainian relative who fled her home with her son. The train was delayed due to bombing on the road ahead. We have friends who are hiding in bomb shelters. We anxiously follow up on them after the air raids, which indiscriminately fire at hospitals, schools, kindergartens and houses. We're not taking this from any media. These are our actual experiences. You trust us enough to use our software. We ask that you trust us to say the truth on this. We need your help. Go out and protest this unnecessary war. Stop the bloodshed. Say \"stop the war!\" This package is considered feature-complete, and is now in security-only maintenance mode, following a decision by the Technical Steering Committee . If you have a security issue, please follow our security reporting guidelines . If you wish to take on the role of maintainer, please nominate yourself laminas-config is designed to simplify access to configuration data within applications. It provides a nested object property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of media supporting hierarchical data storage. File issues at https://github.com/laminas/laminas-config/issues Documentation is at https://docs.laminas.dev/laminas-config/","title":"üá∫üá∏ To Citizens of Russia"},{"location":"factory/","text":"The Factory Laminas\\Config\\Factory provides the ability to load configuration files to an array or to a Laminas\\Config\\Config object. The factory has two purposes Loading configuration file(s) Storing a configuration file Storage writes to a single file Storing the configuration always writes to a single file. The factory is not aware of merged configuration files, and as such cannot split configuration to multiple files. If you want to store particular configuration sections to separate files, you should separate them manually. Loading configuration files The first example illustrates loading a single configuration file: // Load a PHP file as array: $config = Laminas\\Config\\Factory::fromFile(__DIR__ . '/config/my.config.php'); // Load an XML file as Config object; the second parameter, when true, // casts the configuration to a Config instance: $config = Laminas\\Config\\Factory::fromFile(__DIR__.'/config/my.config.xml', true); The next example demonstrates merging multiple files; note that they are in separate formats! $config = Laminas\\Config\\Factory::fromFiles([ __DIR__.'/config/my.config.php', __DIR__.'/config/my.config.xml', ]); Storing configuration Sometimes you may want to write configuration to a file. To do this, use the factory's toFile() method: $config = new Laminas\\Config\\Config([], true); $config-&gt;settings = []; $config-&gt;settings-&gt;myname = 'framework'; $config-&gt;settings-&gt;date = '2012-12-12 12:12:12'; //Store the configuration Laminas\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config); //Store an array $config = [ 'settings' =&gt; [ 'myname' =&gt; 'framework', 'data' =&gt; '2012-12-12 12:12:12', ], ]; Laminas\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);","title":"Config Factory"},{"location":"factory/#the-factory","text":"Laminas\\Config\\Factory provides the ability to load configuration files to an array or to a Laminas\\Config\\Config object. The factory has two purposes Loading configuration file(s) Storing a configuration file","title":"The Factory"},{"location":"factory/#loading-configuration-files","text":"The first example illustrates loading a single configuration file: // Load a PHP file as array: $config = Laminas\\Config\\Factory::fromFile(__DIR__ . '/config/my.config.php'); // Load an XML file as Config object; the second parameter, when true, // casts the configuration to a Config instance: $config = Laminas\\Config\\Factory::fromFile(__DIR__.'/config/my.config.xml', true); The next example demonstrates merging multiple files; note that they are in separate formats! $config = Laminas\\Config\\Factory::fromFiles([ __DIR__.'/config/my.config.php', __DIR__.'/config/my.config.xml', ]);","title":"Loading configuration files"},{"location":"factory/#storing-configuration","text":"Sometimes you may want to write configuration to a file. To do this, use the factory's toFile() method: $config = new Laminas\\Config\\Config([], true); $config-&gt;settings = []; $config-&gt;settings-&gt;myname = 'framework'; $config-&gt;settings-&gt;date = '2012-12-12 12:12:12'; //Store the configuration Laminas\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config); //Store an array $config = [ 'settings' =&gt; [ 'myname' =&gt; 'framework', 'data' =&gt; '2012-12-12 12:12:12', ], ]; Laminas\\Config\\Factory::toFile(__DIR__ . '/config/my.config.php', $config);","title":"Storing configuration"},{"location":"intro/","text":"Introduction laminas-config is designed to simplify access to configuration data within applications. It provides a nested object, property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of formats supporting hierarchical data storage. Currently, laminas-config provides adapters that read and write configuration data stored in INI, JSON, YAML, and XML files. Using Reader Classes Normally, users will use one of the reader classes to read a configuration file, but if configuration data is available in a PHP array, one may simply pass the data to Laminas\\Config\\Config 's constructor in order to utilize a simple object-oriented interface: // An array of configuration data is given $configArray = [ 'webhost' =&gt; 'www.example.com', 'database' =&gt; [ 'adapter' =&gt; 'pdo_mysql', 'params' =&gt; [ 'host' =&gt; 'db.example.com', 'username' =&gt; 'dbuser', 'password' =&gt; 'secret', 'dbname' =&gt; 'mydatabase', ], ], ]; // Create the object-oriented wrapper using the configuration data $config = new Laminas\\Config\\Config($configArray); // Print a configuration datum (results in 'www.example.com') echo $config-&gt;webhost; As illustrated in the example above, Laminas\\Config\\Config provides nested object property syntax to access configuration data passed to its constructor. Along with the object-oriented access to the data values, Laminas\\Config\\Config also has a get() method that accepts a default value to return if the data element requested doesn't exist in the configuration array. For example: $host = $config-&gt;database-&gt;get('host', 'localhost'); Using PHP Configuration Files PHP-based configuration files are often recommended due to the speed with which they are parsed, and the fact that they can be cached by opcode caches. The following code illustrates how to use PHP configuration files. Create a sepatared PHP file which contains the configuration, e.g. config.php : return [ 'webhost' =&gt; 'www.example.com', 'database' =&gt; [ 'adapter' =&gt; 'pdo_mysql', 'params' =&gt; [ 'host' =&gt; 'db.example.com', 'username' =&gt; 'dbuser', 'password' =&gt; 'secret', 'dbname' =&gt; 'mydatabase', ], ], ]; Use the configuration array from this file in another PHP script, e.g. index.php : $config = new Laminas\\Config\\Config(include 'config.php'); echo $config-&gt;webhost; // 'www.example.com'","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-config is designed to simplify access to configuration data within applications. It provides a nested object, property-based user interface for accessing this configuration data within application code. The configuration data may come from a variety of formats supporting hierarchical data storage. Currently, laminas-config provides adapters that read and write configuration data stored in INI, JSON, YAML, and XML files.","title":"Introduction"},{"location":"intro/#using-reader-classes","text":"Normally, users will use one of the reader classes to read a configuration file, but if configuration data is available in a PHP array, one may simply pass the data to Laminas\\Config\\Config 's constructor in order to utilize a simple object-oriented interface: // An array of configuration data is given $configArray = [ 'webhost' =&gt; 'www.example.com', 'database' =&gt; [ 'adapter' =&gt; 'pdo_mysql', 'params' =&gt; [ 'host' =&gt; 'db.example.com', 'username' =&gt; 'dbuser', 'password' =&gt; 'secret', 'dbname' =&gt; 'mydatabase', ], ], ]; // Create the object-oriented wrapper using the configuration data $config = new Laminas\\Config\\Config($configArray); // Print a configuration datum (results in 'www.example.com') echo $config-&gt;webhost; As illustrated in the example above, Laminas\\Config\\Config provides nested object property syntax to access configuration data passed to its constructor. Along with the object-oriented access to the data values, Laminas\\Config\\Config also has a get() method that accepts a default value to return if the data element requested doesn't exist in the configuration array. For example: $host = $config-&gt;database-&gt;get('host', 'localhost');","title":"Using Reader Classes"},{"location":"intro/#using-php-configuration-files","text":"PHP-based configuration files are often recommended due to the speed with which they are parsed, and the fact that they can be cached by opcode caches. The following code illustrates how to use PHP configuration files. Create a sepatared PHP file which contains the configuration, e.g. config.php : return [ 'webhost' =&gt; 'www.example.com', 'database' =&gt; [ 'adapter' =&gt; 'pdo_mysql', 'params' =&gt; [ 'host' =&gt; 'db.example.com', 'username' =&gt; 'dbuser', 'password' =&gt; 'secret', 'dbname' =&gt; 'mydatabase', ], ], ]; Use the configuration array from this file in another PHP script, e.g. index.php : $config = new Laminas\\Config\\Config(include 'config.php'); echo $config-&gt;webhost; // 'www.example.com'","title":"Using PHP Configuration Files"},{"location":"processor/","text":"Laminas\\Config\\Processor Laminas\\Config\\Processor provides the ability to perform operations on a Laminas\\Config\\Config object. Laminas\\Config\\Processor is itself an interface that defining two methods: process() and processValue() . laminas-config provides the following concrete implementations: Laminas\\Config\\Processor\\Constant : manage PHP constant values. Laminas\\Config\\Processor\\Filter : filter the configuration data using Laminas\\Filter . Laminas\\Config\\Processor\\Queue : manage a queue of operations to apply to configuration data. Laminas\\Config\\Processor\\Token : find and replace specific tokens. Laminas\\Config\\Processor\\Translator : translate configuration values in other languages using Laminas\\I18n\\Translator . What gets processed? Typically, you will process configuration values . However, there are use cases for supplying constant and/or token keys ; one common one is for using class-based constants as keys to avoid using magic \"strings\": { \"Acme\\\\Compoment::CONFIG_KEY\": {} } As such, as of version 3.1.0, the Constant and Token processors can optionally also process the keys of the Config instance provided to them, by calling enableKeyProcessing() on their instances, or passing a boolean true value for the fourth constructor argument. Laminas\\Config\\Processor\\Constant Using Laminas\\Config\\Processor\\Constant This example illustrates the basic usage of Laminas\\Config\\Processor\\Constant : define ('TEST_CONST', 'bar'); // Provide the second parameter as boolean true to allow modifications: $config = new Laminas\\Config\\Config(['foo' =&gt; 'TEST_CONST'], true); $processor = new Laminas\\Config\\Processor\\Constant(); echo $config-&gt;foo . ','; $processor-&gt;process($config); echo $config-&gt;foo; This example returns the output: TEST_CONST,bar . As of version 3.1.0, you can also tell the Constant processor to process keys: // At instantiation: $processor = new Laminas\\Config\\Processor\\Constant(true, '', '', true); // Or later, via a method call: $processor-&gt;enableKeyProcessing(); When enabled, any constant values found in keys will also be replaced. Laminas\\Config\\Processor\\Filter Using Laminas\\Config\\Processor\\Filter This example illustrates basic usage of Laminas\\Config\\Processor\\Filter : use Laminas\\Filter\\StringToUpper; use Laminas\\Config\\Processor\\Filter as FilterProcessor; use Laminas\\Config\\Config; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['foo' =&gt; 'bar'], true); $upper = new StringToUpper(); $upperProcessor = new FilterProcessor($upper); echo $config-&gt;foo . ','; $upperProcessor-&gt;process($config); echo $config-&gt;foo; This example returns the output: bar,BAR . Laminas\\Config\\Processor\\Queue Using Laminas\\Config\\Processor\\Queue This example illustrates basic usage of Laminas\\Config\\Processor\\Queue : use Laminas\\Filter\\StringToLower; use Laminas\\Filter\\StringToUpper; use Laminas\\Config\\Processor\\Filter as FilterProcessor; use Laminas\\Config\\Processor\\Queue; use Laminas\\Config\\Config; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['foo' =&gt; 'bar'], true); $upper = new StringToUpper(); $lower = new StringToLower(); $lowerProcessor = new FilterProcessor($lower); $upperProcessor = new FilterProcessor($upper); $queue = new Queue(); $queue-&gt;insert($upperProcessor); $queue-&gt;insert($lowerProcessor); $queue-&gt;process($config); echo $config-&gt;foo; This example returns the output: bar . The filters in the queue are applied in FIFO (First In, First Out) order . Laminas\\Config\\Processor\\Token Using Laminas\\Config\\Processor\\Token This example illustrates basic usage of Laminas\\Config\\Processor\\Token : use Laminas\\Config\\Config; use Laminas\\Config\\Processor\\Token as TokenProcessor; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['foo' =&gt; 'Value is TOKEN'], true); $processor = new TokenProcessor(); $processor-&gt;addToken('TOKEN', 'bar'); echo $config-&gt;foo . ','; $processor-&gt;process($config); echo $config-&gt;foo; This example returns the output: Value is TOKEN,Value is bar . As of version 3.1.0, you can also tell the Token processor to process keys: // At instantiation: $processor = new Laminas\\Config\\Processor\\Token($tokens, '', '', true); // Or later, via a method call: $processor-&gt;enableKeyProcessing(); When enabled, any token values found in keys will also be replaced. Using Token processor as a simple environment processor Token processor can be utilized to populate config values using common format %env(ENV_VAR)% with values from environment by setting Token processor $prefix and $suffix parameters to %env( and )% respectively: use Laminas\\Config\\Config; use Laminas\\Config\\Processor\\Token as TokenProcessor; putenv('AMQP_PASSWORD=guest'); // Populate list if tokens to replace from environment: $processor = new TokenProcessor(getenv(), '%env(', ')%'); // Provide the second parameter as boolean true to allow modifications: $config = new Config([ 'host' =&gt; '127.0.0.1', 'port' =&gt; 5672, 'username' =&gt; '%env(AMQP_USER)%', 'password' =&gt; '%env(AMQP_PASSWORD)%', 'vhost' =&gt; '/', ], true); $processor-&gt;process($config); print_r($config-&gt;toArray()); // Array // ( // [host] =&gt; 127.0.0.1 // [port] =&gt; 5672 // [username] =&gt; %env(AMQP_USER)% // [password] =&gt; guest // [vhost] =&gt; / // ) Do note, however, that only values present in environment will be replaced. This allows multiple fallback processors to be provided as a queue. Laminas\\Config\\Processor\\Translator Using Laminas\\Config\\Processor\\Translator This example illustrates basic usage of Laminas\\Config\\Processor\\Translator : use Laminas\\Config\\Config; use Laminas\\Config\\Processor\\Translator as TranslatorProcessor; use Laminas\\I18n\\Translator\\Translator; // Provide the second parameter as boolean true to allow modifications: $config = new Config(['animal' =&gt; 'dog'], true); /* * The following mapping is used for the translation * loader provided to the translator instance: * * $italian = [ * 'dog' =&gt; 'cane' * ]; */ $translator = new Translator(); // ... configure the translator ... $processor = new TranslatorProcessor($translator); echo \"English: {$config-&gt;animal}, \"; $processor-&gt;process($config); echo \"Italian: {$config-&gt;animal}\"; This example returns the output: English: dog,Italian: cane .","title":"Laminas\\Config\\Processor"},{"location":"processor/#laminasconfigprocessor","text":"Laminas\\Config\\Processor provides the ability to perform operations on a Laminas\\Config\\Config object. Laminas\\Config\\Processor is itself an interface that defining two methods: process() and processValue() . laminas-config provides the following concrete implementations: Laminas\\Config\\Processor\\Constant : manage PHP constant values. Laminas\\Config\\Processor\\Filter : filter the configuration data using Laminas\\Filter . Laminas\\Config\\Processor\\Queue : manage a queue of operations to apply to configuration data. Laminas\\Config\\Processor\\Token : find and replace specific tokens. Laminas\\Config\\Processor\\Translator : translate configuration values in other languages using Laminas\\I18n\\Translator .","title":"Laminas\\Config\\Processor"},{"location":"processor/#laminasconfigprocessorconstant","text":"","title":"Laminas\\Config\\Processor\\Constant"},{"location":"processor/#laminasconfigprocessorfilter","text":"","title":"Laminas\\Config\\Processor\\Filter"},{"location":"processor/#laminasconfigprocessorqueue","text":"","title":"Laminas\\Config\\Processor\\Queue"},{"location":"processor/#laminasconfigprocessortoken","text":"","title":"Laminas\\Config\\Processor\\Token"},{"location":"processor/#laminasconfigprocessortranslator","text":"","title":"Laminas\\Config\\Processor\\Translator"},{"location":"reader/","text":"Laminas\\Config\\Reader Laminas\\Config\\Reader gives you the ability to read a config file. It works with concrete implementations for different file formats. Laminas\\Config\\Reader itself is only an interface, defining the methods fromFile() and fromString() . The concrete implementations of this interface are: Laminas\\Config\\Reader\\Ini Laminas\\Config\\Reader\\Xml Laminas\\Config\\Reader\\Json Laminas\\Config\\Reader\\Yaml Laminas\\Config\\Reader\\JavaProperties fromFile() and fromString() are expected to return a PHP array containing the data from the specified configuration. Differences from Laminas1 The Laminas\\Config\\Reader component no longer supports the following features: Inheritance of sections. Reading of specific sections. Laminas\\Config\\Reader\\Ini Laminas\\Config\\Reader\\Ini enables developers to store configuration data in a familiar INI format, and then to read them in the application by using an array syntax. Laminas\\Config\\Reader\\Ini utilizes the parse_ini_file() PHP function. Please review this documentation to be aware of its specific behaviors, which propagate to Laminas\\Config\\Reader\\Ini , such as how the special values of TRUE , FALSE , \"yes\", \"no\", and NULL are handled. Key Separator By default, the key separator character is the period character ( . ). This can be changed, however, using the setNestSeparator() method. For example: $reader = new Laminas\\Config\\Reader\\Ini(); $reader-&gt;setNestSeparator('-'); Process Sections By default, the INI reader executes parse_ini_file() with the optional parameter $process_sections being true . The result is a multidimensional array, with the section names and settings included. To merge sections, set the parameter via setProcessSections() to false as follows. $reader = new Laminas\\Config\\Reader\\Ini(); $reader-&gt;setProcessSections(false); Typed Mode By default, the INI reader executes parse_ini_file() with the optional parameter $scanner_mode set to INI_SCANNER_NORMAL . This results in all config values being returned as strings. To automatically return integer, boolean, and null values as the appropriate types, switch to typed mode with setTypedMode() , and parse_ini_file() will be called with INI_SCANNER_TYPED instead. $reader = new Laminas\\Config\\Reader\\Ini(); $reader-&gt;setTypedMode(true); The following example illustrates basic usage of Laminas\\Config\\Reader\\Ini for loading configuration data from an INI file. In this example, configuration data for both a production system and for a staging system exists. webhost = 'www.example.com' database.adapter = 'pdo_mysql' database.params.host = 'db.example.com' database.params.username = 'dbuser' database.params.password = 'secret' database.params.dbname = 'dbproduction' We can use Laminas\\Config\\Reader\\Ini to read this INI file: $reader = new Laminas\\Config\\Reader\\Ini(); $data = $reader-&gt;fromFile('/path/to/config.ini'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" Laminas\\Config\\Reader\\Ini supports a feature to include the content of a INI file in a specific section of another INI file. For instance, suppose we have an INI file with the database configuration: database.adapter = 'pdo_mysql' database.params.host = 'db.example.com' database.params.username = 'dbuser' database.params.password = 'secret' database.params.dbname = 'dbproduction' We can include this configuration in another INI file by using the @include notation: webhost = 'www.example.com' @include = 'database.ini' If we read this file using the component Laminas\\Config\\Reader\\Ini , we will obtain the same configuration data structure as in the previous example. The @include = 'file-to-include.ini' notation can be used also in a subelement of a value. For instance we can have an INI file like the following: adapter = 'pdo_mysql' params.host = 'db.example.com' params.username = 'dbuser' params.password = 'secret' params.dbname = 'dbproduction' And assign the @include as a subelement of the database value: webhost = 'www.example.com' database.@include = 'database.ini' Laminas\\Config\\Reader\\Xml Laminas\\Config\\Reader\\Xml enables developers to provide configuration data in a familiar XML format and consume it in the application using an array syntax. The root element of the XML file or string is irrelevant and may be named arbitrarily. The following example illustrates basic usage of Laminas\\Config\\Reader\\Xml for loading configuration data from an XML file. First, our XML configuration in the file config.xml : &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;config&gt; &lt;webhost&gt;www.example.com&lt;/webhost&gt; &lt;database&gt; &lt;adapter value=\"pdo_mysql\"/&gt; &lt;params&gt; &lt;host value=\"db.example.com\"/&gt; &lt;username value=\"dbuser\"/&gt; &lt;password value=\"secret\"/&gt; &lt;dbname value=\"dbproduction\"/&gt; &lt;/params&gt; &lt;/database&gt; &lt;/config&gt; We can use the Laminas\\Config\\Reader\\Xml to read the XML configuration: $reader = new Laminas\\Config\\Reader\\Xml(); $data = $reader-&gt;fromFile('/path/to/config.xml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']['value']; // prints \"dbproduction\" Laminas\\Config\\Reader\\Xml utilizes PHP's XMLReader class. Please review its documentation to be aware of its specific behaviors, which propagate to Laminas\\Config\\Reader\\Xml . Using Laminas\\Config\\Reader\\Xml , we can include the content of XML files in a specific XML element. This is provided using the standard XInclude functionality of XML. To use this functionality, you must add the namespace xmlns:xi=\"http://www.w3.org/2001/XInclude\" to the XML file. Suppose we have an XML file that contains only the database configuration: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;config&gt; &lt;database&gt; &lt;adapter&gt;pdo_mysql&lt;/adapter&gt; &lt;params&gt; &lt;host&gt;db.example.com&lt;/host&gt; &lt;username&gt;dbuser&lt;/username&gt; &lt;password&gt;secret&lt;/password&gt; &lt;dbname&gt;dbproduction&lt;/dbname&gt; &lt;/params&gt; &lt;/database&gt; &lt;/config&gt; We can include this configuration in another XML file using an xinclude: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;config xmlns:xi=\"http://www.w3.org/2001/XInclude\"&gt; &lt;webhost&gt;www.example.com&lt;/webhost&gt; &lt;xi:include href=\"database.xml\"/&gt; &lt;/config&gt; The syntax to include an XML file in a specific element is &lt;xi:include href=\"file-to-include.xml\"/&gt; Laminas\\Config\\Reader\\Json Laminas\\Config\\Reader\\Json enables developers to consume configuration data in JSON, and read it in the application by using an array syntax. The following example illustrates a basic use of Laminas\\Config\\Reader\\Json for loading configuration data from a JSON file. Consider the following JSON configuration file: { \"webhost\" : \"www.example.com\", \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } We can use Laminas\\Config\\Reader\\Json to read the file: $reader = new Laminas\\Config\\Reader\\Json(); $data = $reader-&gt;fromFile('/path/to/config.json'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" Laminas\\Config\\Reader\\Json utilizes laminas-json . Using Laminas\\Config\\Reader\\Json , we can include the content of a JSON file in a specific JSON section or element. This is provided using the special syntax @include . Suppose we have a JSON file that contains only the database configuration: { \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } Now let's include it via another configuration file: { \"webhost\" : \"www.example.com\", \"@include\" : \"database.json\" } Laminas\\Config\\Reader\\Yaml Laminas\\Config\\Reader\\Yaml enables developers to consume configuration data in a YAML format, and read them in the application by using an array syntax. In order to use the YAML reader, we need to pass a callback to an external PHP library or use the YAML PECL extension . The following example illustrates basic usage of Laminas\\Config\\Reader\\Yaml , using the YAML PECL extension. Consider the following YAML file: webhost: www.example.com database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can use Laminas\\Config\\Reader\\Yaml to read this YAML file: $reader = new Laminas\\Config\\Reader\\Yaml(); $data = $reader-&gt;fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" If you want to use an external YAML reader, you must pass a callback function to the class constructor. For instance, if you want to use the Spyc library: // include the Spyc library require_once 'path/to/spyc.php'; $reader = new Laminas\\Config\\Reader\\Yaml(['Spyc', 'YAMLLoadString']); $data = $reader-&gt;fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" You can also instantiate Laminas\\Config\\Reader\\Yaml without any parameters, and specify the YAML reader using the setYamlDecoder() method. Using Laminas\\Config\\ReaderYaml , we can include the content of another YAML file in a specific YAML section or element. This is provided using the special syntax @include . Consider the following YAML file containing only database configuration: database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can include this configuration in another YAML file: webhost: www.example.com @include: database.yaml Laminas\\Config\\Reader\\JavaProperties Laminas\\Config\\Reader\\JavaProperties enables developers to provide configuration data in the popular JavaProperties format, and read it in the application by using array syntax. The following example illustrates basic usage of Laminas\\Config\\Reader\\JavaProperties for loading configuration data from a JavaProperties file. Suppose we have the following JavaProperties configuration file: #comment !comment webhost:www.example.com database.adapter:pdo_mysql database.params.host:db.example.com database.params.username:dbuser database.params.password:secret database.params.dbname:dbproduction We can use Laminas\\Config\\Reader\\JavaProperties to read it: $reader = new Laminas\\Config\\Reader\\JavaProperties(); $data = $reader-&gt;fromFile('/path/to/config.properties'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database.params.dbname']; // prints \"dbproduction\" Alternate delimiters Since 3.2.0 By default, the JavaProperties reader will assume that the delimiter between key/value pairs is : . If you wish to use an alternate delimiter, pass it as the first argument to the constructor: $reader = new JavaProperties('='); // Use = as the delimiter When specifying the default delimiter, you can use either : or the constant JavaProperties::DELIMITER_DEFAULT . Trimming whitespace Since 3.2.0 By default, whitespace is considered significant in JavaProperties files, including trailing whitespace. If you wish to have keys and values trimmed during parsing, you can pass a boolean true value, or the constant JavaProperties::WHITESPACE_TRIM , as the second argument to the constructor: $reader = new JavaProperties( JavaProperties::DELIMITER_DEFAULT, // use default delimiter JavaProperties::WHITESPACE_TRIM ); This can be useful particularly when surrounding the delimiter with whitespace: webhost = www.example.com database.adapter = pdo_mysql database.params.host = db.example.com database.params.username = dbuser database.params.password = secret database.params.dbname = dbproduction","title":"Laminas\\Config\\Reader"},{"location":"reader/#laminasconfigreader","text":"Laminas\\Config\\Reader gives you the ability to read a config file. It works with concrete implementations for different file formats. Laminas\\Config\\Reader itself is only an interface, defining the methods fromFile() and fromString() . The concrete implementations of this interface are: Laminas\\Config\\Reader\\Ini Laminas\\Config\\Reader\\Xml Laminas\\Config\\Reader\\Json Laminas\\Config\\Reader\\Yaml Laminas\\Config\\Reader\\JavaProperties fromFile() and fromString() are expected to return a PHP array containing the data from the specified configuration.","title":"Laminas\\Config\\Reader"},{"location":"reader/#laminasconfigreaderini","text":"Laminas\\Config\\Reader\\Ini enables developers to store configuration data in a familiar INI format, and then to read them in the application by using an array syntax. Laminas\\Config\\Reader\\Ini utilizes the parse_ini_file() PHP function. Please review this documentation to be aware of its specific behaviors, which propagate to Laminas\\Config\\Reader\\Ini , such as how the special values of TRUE , FALSE , \"yes\", \"no\", and NULL are handled.","title":"Laminas\\Config\\Reader\\Ini"},{"location":"reader/#laminasconfigreaderxml","text":"Laminas\\Config\\Reader\\Xml enables developers to provide configuration data in a familiar XML format and consume it in the application using an array syntax. The root element of the XML file or string is irrelevant and may be named arbitrarily. The following example illustrates basic usage of Laminas\\Config\\Reader\\Xml for loading configuration data from an XML file. First, our XML configuration in the file config.xml : &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;config&gt; &lt;webhost&gt;www.example.com&lt;/webhost&gt; &lt;database&gt; &lt;adapter value=\"pdo_mysql\"/&gt; &lt;params&gt; &lt;host value=\"db.example.com\"/&gt; &lt;username value=\"dbuser\"/&gt; &lt;password value=\"secret\"/&gt; &lt;dbname value=\"dbproduction\"/&gt; &lt;/params&gt; &lt;/database&gt; &lt;/config&gt; We can use the Laminas\\Config\\Reader\\Xml to read the XML configuration: $reader = new Laminas\\Config\\Reader\\Xml(); $data = $reader-&gt;fromFile('/path/to/config.xml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']['value']; // prints \"dbproduction\" Laminas\\Config\\Reader\\Xml utilizes PHP's XMLReader class. Please review its documentation to be aware of its specific behaviors, which propagate to Laminas\\Config\\Reader\\Xml . Using Laminas\\Config\\Reader\\Xml , we can include the content of XML files in a specific XML element. This is provided using the standard XInclude functionality of XML. To use this functionality, you must add the namespace xmlns:xi=\"http://www.w3.org/2001/XInclude\" to the XML file. Suppose we have an XML file that contains only the database configuration: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;config&gt; &lt;database&gt; &lt;adapter&gt;pdo_mysql&lt;/adapter&gt; &lt;params&gt; &lt;host&gt;db.example.com&lt;/host&gt; &lt;username&gt;dbuser&lt;/username&gt; &lt;password&gt;secret&lt;/password&gt; &lt;dbname&gt;dbproduction&lt;/dbname&gt; &lt;/params&gt; &lt;/database&gt; &lt;/config&gt; We can include this configuration in another XML file using an xinclude: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;config xmlns:xi=\"http://www.w3.org/2001/XInclude\"&gt; &lt;webhost&gt;www.example.com&lt;/webhost&gt; &lt;xi:include href=\"database.xml\"/&gt; &lt;/config&gt; The syntax to include an XML file in a specific element is &lt;xi:include href=\"file-to-include.xml\"/&gt;","title":"Laminas\\Config\\Reader\\Xml"},{"location":"reader/#laminasconfigreaderjson","text":"Laminas\\Config\\Reader\\Json enables developers to consume configuration data in JSON, and read it in the application by using an array syntax. The following example illustrates a basic use of Laminas\\Config\\Reader\\Json for loading configuration data from a JSON file. Consider the following JSON configuration file: { \"webhost\" : \"www.example.com\", \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } We can use Laminas\\Config\\Reader\\Json to read the file: $reader = new Laminas\\Config\\Reader\\Json(); $data = $reader-&gt;fromFile('/path/to/config.json'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" Laminas\\Config\\Reader\\Json utilizes laminas-json . Using Laminas\\Config\\Reader\\Json , we can include the content of a JSON file in a specific JSON section or element. This is provided using the special syntax @include . Suppose we have a JSON file that contains only the database configuration: { \"database\" : { \"adapter\" : \"pdo_mysql\", \"params\" : { \"host\" : \"db.example.com\", \"username\" : \"dbuser\", \"password\" : \"secret\", \"dbname\" : \"dbproduction\" } } } Now let's include it via another configuration file: { \"webhost\" : \"www.example.com\", \"@include\" : \"database.json\" }","title":"Laminas\\Config\\Reader\\Json"},{"location":"reader/#laminasconfigreaderyaml","text":"Laminas\\Config\\Reader\\Yaml enables developers to consume configuration data in a YAML format, and read them in the application by using an array syntax. In order to use the YAML reader, we need to pass a callback to an external PHP library or use the YAML PECL extension . The following example illustrates basic usage of Laminas\\Config\\Reader\\Yaml , using the YAML PECL extension. Consider the following YAML file: webhost: www.example.com database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can use Laminas\\Config\\Reader\\Yaml to read this YAML file: $reader = new Laminas\\Config\\Reader\\Yaml(); $data = $reader-&gt;fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" If you want to use an external YAML reader, you must pass a callback function to the class constructor. For instance, if you want to use the Spyc library: // include the Spyc library require_once 'path/to/spyc.php'; $reader = new Laminas\\Config\\Reader\\Yaml(['Spyc', 'YAMLLoadString']); $data = $reader-&gt;fromFile('/path/to/config.yaml'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database']['params']['dbname']; // prints \"dbproduction\" You can also instantiate Laminas\\Config\\Reader\\Yaml without any parameters, and specify the YAML reader using the setYamlDecoder() method. Using Laminas\\Config\\ReaderYaml , we can include the content of another YAML file in a specific YAML section or element. This is provided using the special syntax @include . Consider the following YAML file containing only database configuration: database: adapter: pdo_mysql params: host: db.example.com username: dbuser password: secret dbname: dbproduction We can include this configuration in another YAML file: webhost: www.example.com @include: database.yaml","title":"Laminas\\Config\\Reader\\Yaml"},{"location":"reader/#laminasconfigreaderjavaproperties","text":"Laminas\\Config\\Reader\\JavaProperties enables developers to provide configuration data in the popular JavaProperties format, and read it in the application by using array syntax. The following example illustrates basic usage of Laminas\\Config\\Reader\\JavaProperties for loading configuration data from a JavaProperties file. Suppose we have the following JavaProperties configuration file: #comment !comment webhost:www.example.com database.adapter:pdo_mysql database.params.host:db.example.com database.params.username:dbuser database.params.password:secret database.params.dbname:dbproduction We can use Laminas\\Config\\Reader\\JavaProperties to read it: $reader = new Laminas\\Config\\Reader\\JavaProperties(); $data = $reader-&gt;fromFile('/path/to/config.properties'); echo $data['webhost']; // prints \"www.example.com\" echo $data['database.params.dbname']; // prints \"dbproduction\"","title":"Laminas\\Config\\Reader\\JavaProperties"},{"location":"theory/","text":"Theory of Operation Configuration data are made accessible to Laminas\\Config\\Config 's constructor via an associative array, which may be multi-dimensional so data can be organized from general to specific. Concrete adapter classes adapt configuration data from storage to produce the associative array for Laminas\\Config\\Config 's constructor. If needed, user scripts may provide such arrays directly to Laminas\\Config\\Config 's constructor, without using a reader class. Each value in the configuration data array becomes a property of the Laminas\\Config\\Config object. The key is used as the property name. If a value is itself an array, then the resulting object property is created as a new Laminas\\Config\\Config object, loaded with the array data. This occurs recursively, such that a hierarchy of configuration data may be created with any number of levels. Extending Laminas\\Config\\Config class If you decide to extend Laminas\\Config\\Config class, each property (subnode) becomes the same type as the parent class. For example: class ExtendedConfig extends Laminas\\Config\\Config { } $config = new ExtendedConfig(['node' =&gt; ['key' =&gt; 'value']]); echo get_class($config-&gt;node); // the result of above is ExtendedConfig not Laminas\\Config\\Config! This casting occurs in the constructor, which uses the construct new static() for any array subvalues it encounters when traversing the provided array. As such, we DO NOT RECOMMEND extending the constructor; instead, create a named constructor : class ExtendedConfig extends Laminas\\Config\\Config { public static function createWithDefaults() { return new self([ /* ... */ ]); } } Laminas\\Config\\Config implements the Countable and Iterator interfaces in order to facilitate simple access to configuration data. Thus, Laminas\\Config\\Config objects support the count() function and PHP constructs such as foreach . By default, configuration data made available through Laminas\\Config\\Config are read-only, and an assignment (e.g., $config-&gt;database-&gt;host = 'example.com'; ) results in an exception. This default behavior may be overridden through the constructor, allowing modification of data values. Also, when modifications are allowed, Laminas\\Config\\Config supports unsetting of values (e.g., unset($config-&gt;database-&gt;host) ). The isReadOnly() method can be used to determine if modifications to a given Laminas\\Config\\Config object are allowed, and the setReadOnly() method can be used to stop any further modifications to a Laminas\\Config\\Config object that was created allowing modifications. Modifying Config does not save changes It is important not to confuse such in-memory modifications with saving configuration data out to specific storage media. Tools for creating and modifying configuration data for various storage media are out of scope with respect to Laminas\\Config\\Config . Third-party open source solutions are readily available for the purpose of creating and modifying configuration data for various storage media. If you have two Laminas\\Config\\Config objects, you can merge them into a single object using the merge() function. For example, given $config and $localConfig , you can merge data from $localConfig to $config using $config-&gt;merge($localConfig); . The items in $localConfig will override any items with the same name in $config . Merging requires modifications The Laminas\\Config\\Config object that is performing the merge must have been constructed to allow modifications, by passing TRUE as the second parameter of the constructor. The setReadOnly() method can then be used to prevent any further modifications after the merge is complete.","title":"Theory of Operation"},{"location":"theory/#theory-of-operation","text":"Configuration data are made accessible to Laminas\\Config\\Config 's constructor via an associative array, which may be multi-dimensional so data can be organized from general to specific. Concrete adapter classes adapt configuration data from storage to produce the associative array for Laminas\\Config\\Config 's constructor. If needed, user scripts may provide such arrays directly to Laminas\\Config\\Config 's constructor, without using a reader class. Each value in the configuration data array becomes a property of the Laminas\\Config\\Config object. The key is used as the property name. If a value is itself an array, then the resulting object property is created as a new Laminas\\Config\\Config object, loaded with the array data. This occurs recursively, such that a hierarchy of configuration data may be created with any number of levels.","title":"Theory of Operation"},{"location":"writer/","text":"Laminas\\Config\\Writer Laminas\\Config\\Writer provides the ability to write config files from an array, Laminas\\Config\\Config instance, or any Traversable object. Laminas\\Config\\Writer is itself only an interface that defining the methods toFile() and toString() . We have six writers implementing the interface: Laminas\\Config\\Writer\\Ini Laminas\\Config\\Writer\\JavaProperties Laminas\\Config\\Writer\\Json Laminas\\Config\\Writer\\PhpArray Laminas\\Config\\Writer\\Xml Laminas\\Config\\Writer\\Yaml Laminas\\Config\\Writer\\Ini The INI writer has two modes for rendering with regard to sections. By default, the top-level configuration is always written into section names. By calling $writer-&gt;setRenderWithoutSectionsFlags(true); all options are written into the global namespace of the INI file and no sections are applied. Laminas\\Config\\Writer\\Ini has an additional option parameter, nestSeparator , which defines with which character the single nodes are separated. The default is a single dot ( . ), such as is accepted by Laminas\\Config\\Reader\\Ini by default. When modifying or creating a Laminas\\Config\\Config object, there are several considerations to keep in mind. To create or modify a value, you simply say set the parameter of the Config object via the parameter accessor ( -&gt; ). To create a section in the root or to create a branch, just create a new array ( $config-&gt;branch = []; ). Using Laminas\\Config\\Writer\\Ini Consider the following code, which creates a configuration structure: // Create the config object $config = new Laminas\\Config\\Config([], true); $config-&gt;production = []; $config-&gt;production-&gt;webhost = 'www.example.com'; $config-&gt;production-&gt;database = []; $config-&gt;production-&gt;database-&gt;params = []; $config-&gt;production-&gt;database-&gt;params-&gt;host = 'localhost'; $config-&gt;production-&gt;database-&gt;params-&gt;username = 'production'; $config-&gt;production-&gt;database-&gt;params-&gt;password = 'secret'; $config-&gt;production-&gt;database-&gt;params-&gt;dbname = 'dbproduction'; $writer = new Laminas\\Config\\Writer\\Ini(); echo $writer-&gt;toString($config); The result of this code is the following INI string: [production] webhost = \"www.example.com\" database.params.host = \"localhost\" database.params.username = \"production\" database.params.password = \"secret\" database.params.dbname = \"dbproduction\" You can use the method toFile() to store the INI data to a file instead. Laminas\\Config\\Writer\\JavaProperties Since 3.2.0 The JavaProperties writer can only write single-dimensional configuration (i.e., key/value pairs); this is a limitation of the JavaProperties format. Laminas\\Config\\Writer\\JavaProperties has a single, optional constructor parameter, delimiter , which defines with which character the key/value pairs are separated. The default is a single colon ( : ), such as is accepted by Laminas\\Config\\Reader\\JavaProperties by default. Using Laminas\\Config\\Writer\\JavaProperties Consider the following code, creating configuration: // Create the config object $config = new Laminas\\Config\\Config([], true); $config-&gt;webhost = 'www.example.com'; // use object notation $config['database.host'] = 'localhost'; // or array notation, for complex key names $config['database.username'] = 'production'; $config['database.password'] = 'secret'; $config['database.dbname'] = 'dbproduction'; $writer = new Laminas\\Config\\Writer\\JavaProperties(); echo $writer-&gt;toString($config); The result of this code is the following JavaProperties string: webhost:www.example.com database.host:localhost database.username:production database.password:secret database.dbname:dbproduction You can use the method toFile() to store the JavaProperties data to a file instead. Using an alternate delimiter If you want to use an alternate delimiter, such as = , pass it to the constructor: $writer = new Laminas\\Config\\Writer\\JavaProperties('='); Using the above configuration, we would now receive: webhost=www.example.com database.host=localhost database.username=production database.password=secret database.dbname=dbproduction Laminas\\Config\\Writer\\Xml Laminas\\Config\\Writer\\Xml can be used to generate an XML string or file. Using Laminas\\Config\\Writer\\Xml Consider the following code, which creates a configuration structure: // Create the config object $config = new Laminas\\Config\\Config([], true); $config-&gt;production = []; $config-&gt;production-&gt;webhost = 'www.example.com'; $config-&gt;production-&gt;database = []; $config-&gt;production-&gt;database-&gt;params = []; $config-&gt;production-&gt;database-&gt;params-&gt;host = 'localhost'; $config-&gt;production-&gt;database-&gt;params-&gt;username = 'production'; $config-&gt;production-&gt;database-&gt;params-&gt;password = 'secret'; $config-&gt;production-&gt;database-&gt;params-&gt;dbname = 'dbproduction'; $writer = new Laminas\\Config\\Writer\\Xml(); echo $writer-&gt;toString($config); The result of this code is the following XML string: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;laminas-config&gt; &lt;production&gt; &lt;webhost&gt;www.example.com&lt;/webhost&gt; &lt;database&gt; &lt;params&gt; &lt;host&gt;localhost&lt;/host&gt; &lt;username&gt;production&lt;/username&gt; &lt;password&gt;secret&lt;/password&gt; &lt;dbname&gt;dbproduction&lt;/dbname&gt; &lt;/params&gt; &lt;/database&gt; &lt;/production&gt; &lt;/laminas-config&gt; You can use the method toFile() to store the XML data to a file. Laminas\\Config\\Writer\\PhpArray Laminas\\Config\\Writer\\PhpArray can be used to generate a PHP script that represents and returns configuration. Using Laminas\\Config\\Writer\\PhpArray Consider the following code, which creates a configuration structure: // Create the config object $config = new Laminas\\Config\\Config([], true); $config-&gt;production = []; $config-&gt;production-&gt;webhost = 'www.example.com'; $config-&gt;production-&gt;database = []; $config-&gt;production-&gt;database-&gt;params = []; $config-&gt;production-&gt;database-&gt;params-&gt;host = 'localhost'; $config-&gt;production-&gt;database-&gt;params-&gt;username = 'production'; $config-&gt;production-&gt;database-&gt;params-&gt;password = 'secret'; $config-&gt;production-&gt;database-&gt;params-&gt;dbname = 'dbproduction'; $writer = new Laminas\\Config\\Writer\\PhpArray(); echo $writer-&gt;toString($config); The result of this code is the following PHP script: &lt;?php return [ 'production' =&gt; [ 'webhost' =&gt; 'www.example.com', 'database' =&gt; [ 'params' =&gt; [ 'host' =&gt; 'localhost', 'username' =&gt; 'production', 'password' =&gt; 'secret', 'dbname' =&gt; 'dbproduction', ], ], ], ]; You can use the method toFile() to save the PHP script to a file. Laminas\\Config\\Writer\\Json Laminas\\Config\\Writer\\Json can be used to generate a JSON representation of configuration. Using Laminas\\Config\\Writer\\Json Consider the following code, which creates a configuration structure: // Create the config object $config = new Laminas\\Config\\Config([], true); $config-&gt;production = []; $config-&gt;production-&gt;webhost = 'www.example.com'; $config-&gt;production-&gt;database = []; $config-&gt;production-&gt;database-&gt;params = []; $config-&gt;production-&gt;database-&gt;params-&gt;host = 'localhost'; $config-&gt;production-&gt;database-&gt;params-&gt;username = 'production'; $config-&gt;production-&gt;database-&gt;params-&gt;password = 'secret'; $config-&gt;production-&gt;database-&gt;params-&gt;dbname = 'dbproduction'; $writer = new Laminas\\Config\\Writer\\Json(); echo $writer-&gt;toString($config); The result of this code is the following JSON string: { \"webhost\": \"www.example.com\", \"database\": { \"params\": { \"host\": \"localhost\", \"username\": \"production\", \"password\": \"secret\", \"dbname\": \"dbproduction\" } } } You can use the method toFile() to save the JSON data to a file. Laminas\\Config\\Writer\\Json uses the laminas-json component to convert the data to JSON. Laminas\\Config\\Writer\\Yaml Laminas\\Config\\Writer\\Yaml can be used to generate a PHP code that returns the YAML representation of configuration. In order to use the YAML writer, we need to pass a callback to an external PHP library, or use the YAML PECL extension . Using Laminas\\Config\\Writer\\Yaml Consider the following code, which creates a configuration structure using the YAML PECL extension: // Create the config object $config = new Laminas\\Config\\Config([], true); $config-&gt;production = []; $config-&gt;production-&gt;webhost = 'www.example.com'; $config-&gt;production-&gt;database = []; $config-&gt;production-&gt;database-&gt;params = []; $config-&gt;production-&gt;database-&gt;params-&gt;host = 'localhost'; $config-&gt;production-&gt;database-&gt;params-&gt;username = 'production'; $config-&gt;production-&gt;database-&gt;params-&gt;password = 'secret'; $config-&gt;production-&gt;database-&gt;params-&gt;dbname = 'dbproduction'; $writer = new Laminas\\Config\\Writer\\Yaml(); echo $writer-&gt;toString($config); The result of this code is the following YAML string contains the following value: webhost: www.example.com database: params: host: localhost username: production password: secret dbname: dbproduction You can use the method toFile() to save the YAML data to a file. If you want to use an external YAML writer library, pass the callback function that will generate the YAML from the configuration when instantiating the writer. For instance, to use the Spyc library: // include the Spyc library require_once 'path/to/spyc.php'; $writer = new Laminas\\Config\\Writer\\Yaml(['Spyc', 'YAMLDump']); echo $writer-&gt;toString($config);","title":"Laminas\\Config\\Writer"},{"location":"writer/#laminasconfigwriter","text":"Laminas\\Config\\Writer provides the ability to write config files from an array, Laminas\\Config\\Config instance, or any Traversable object. Laminas\\Config\\Writer is itself only an interface that defining the methods toFile() and toString() . We have six writers implementing the interface: Laminas\\Config\\Writer\\Ini Laminas\\Config\\Writer\\JavaProperties Laminas\\Config\\Writer\\Json Laminas\\Config\\Writer\\PhpArray Laminas\\Config\\Writer\\Xml Laminas\\Config\\Writer\\Yaml","title":"Laminas\\Config\\Writer"},{"location":"writer/#laminasconfigwriterini","text":"The INI writer has two modes for rendering with regard to sections. By default, the top-level configuration is always written into section names. By calling $writer-&gt;setRenderWithoutSectionsFlags(true); all options are written into the global namespace of the INI file and no sections are applied. Laminas\\Config\\Writer\\Ini has an additional option parameter, nestSeparator , which defines with which character the single nodes are separated. The default is a single dot ( . ), such as is accepted by Laminas\\Config\\Reader\\Ini by default. When modifying or creating a Laminas\\Config\\Config object, there are several considerations to keep in mind. To create or modify a value, you simply say set the parameter of the Config object via the parameter accessor ( -&gt; ). To create a section in the root or to create a branch, just create a new array ( $config-&gt;branch = []; ).","title":"Laminas\\Config\\Writer\\Ini"},{"location":"writer/#laminasconfigwriterjavaproperties","text":"Since 3.2.0 The JavaProperties writer can only write single-dimensional configuration (i.e., key/value pairs); this is a limitation of the JavaProperties format. Laminas\\Config\\Writer\\JavaProperties has a single, optional constructor parameter, delimiter , which defines with which character the key/value pairs are separated. The default is a single colon ( : ), such as is accepted by Laminas\\Config\\Reader\\JavaProperties by default.","title":"Laminas\\Config\\Writer\\JavaProperties"},{"location":"writer/#laminasconfigwriterxml","text":"Laminas\\Config\\Writer\\Xml can be used to generate an XML string or file.","title":"Laminas\\Config\\Writer\\Xml"},{"location":"writer/#laminasconfigwriterphparray","text":"Laminas\\Config\\Writer\\PhpArray can be used to generate a PHP script that represents and returns configuration.","title":"Laminas\\Config\\Writer\\PhpArray"},{"location":"writer/#laminasconfigwriterjson","text":"Laminas\\Config\\Writer\\Json can be used to generate a JSON representation of configuration.","title":"Laminas\\Config\\Writer\\Json"},{"location":"writer/#laminasconfigwriteryaml","text":"Laminas\\Config\\Writer\\Yaml can be used to generate a PHP code that returns the YAML representation of configuration. In order to use the YAML writer, we need to pass a callback to an external PHP library, or use the YAML PECL extension .","title":"Laminas\\Config\\Writer\\Yaml"},{"location":"migration/to-v3/","text":"Migration to version 3 Version 3 is essentially fully backwards compatible with previous versions, with one key exception: Laminas\\Config\\Factory no longer requires usage of laminas-servicemanager for resolving plugins. The reason this is considered a backwards compatibility break is due to signature changes: Factory::setReaderPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Laminas\\Config\\ReaderPluginManager instance; ReaderPluginManager , however, still fulfills that typehint. Factory::getReaderPluginManager() now returns a Psr\\Container\\ContainerInterface ‚Äî specifically, a Laminas\\Config\\StandaloneReaderPluginManager ‚Äî and not a Laminas\\Config\\ReaderPluginManager instance, by default; ReaderPluginManager , however, still fulfills that typehint. Factory::setWriterPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Laminas\\Config\\WriterPluginManager instance; WriterPluginManager , however, still fulfills that typehint. Factory::getWriterPluginManager() now returns a Psr\\Container\\ContainerInterface ‚Äî specifically, a Laminas\\Config\\StandaloneWriterPluginManager ‚Äî and not a Laminas\\Config\\WriterPluginManager instance, by default; WriterPluginManager , however, still fulfills that typehint. If you were extending the class, you will need to update your signatures accordingly. This particular update means that you may use any PSR-11 container as a reader or writer plugin manager, and no longer require installation of laminas-servicemanager to use the plugin manager facilities.","title":"To version 3"},{"location":"migration/to-v3/#migration-to-version-3","text":"Version 3 is essentially fully backwards compatible with previous versions, with one key exception: Laminas\\Config\\Factory no longer requires usage of laminas-servicemanager for resolving plugins. The reason this is considered a backwards compatibility break is due to signature changes: Factory::setReaderPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Laminas\\Config\\ReaderPluginManager instance; ReaderPluginManager , however, still fulfills that typehint. Factory::getReaderPluginManager() now returns a Psr\\Container\\ContainerInterface ‚Äî specifically, a Laminas\\Config\\StandaloneReaderPluginManager ‚Äî and not a Laminas\\Config\\ReaderPluginManager instance, by default; ReaderPluginManager , however, still fulfills that typehint. Factory::setWriterPluginManager() now accepts a Psr\\Container\\ContainerInterface , and not a Laminas\\Config\\WriterPluginManager instance; WriterPluginManager , however, still fulfills that typehint. Factory::getWriterPluginManager() now returns a Psr\\Container\\ContainerInterface ‚Äî specifically, a Laminas\\Config\\StandaloneWriterPluginManager ‚Äî and not a Laminas\\Config\\WriterPluginManager instance, by default; WriterPluginManager , however, still fulfills that typehint. If you were extending the class, you will need to update your signatures accordingly. This particular update means that you may use any PSR-11 container as a reader or writer plugin manager, and no longer require installation of laminas-servicemanager to use the plugin manager facilities.","title":"Migration to version 3"}]}